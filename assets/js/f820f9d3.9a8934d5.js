"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1395],{3047:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/concurrent-replace","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/concurrent-replace.md","source":"@site/blog/concurrent-replace.md","title":"Avoid \\"REPLACE INTO\\"","description":"In distributed systems, Upsert (Update or Insert) is a fundamental operation. You want to store a record: if it exists, update it; if not, create it.","date":"2025-12-29T00:00:00.000Z","tags":[],"readingTime":5.17,"hasTruncateMarker":false,"authors":[{"name":"Ashish Rathod","title":"Ex-Intuit Staff Engineer","url":"https://www.linkedin.com/in/ashish-rathod02/","page":{"permalink":"/docs/blog/authors/ashish"},"socials":{"linkedin":"https://www.linkedin.com/in/ashish-rathod02/","github":"https://github.com/arathod02"},"imageURL":"https://github.com/arathod02.png","key":"ashish"}],"frontMatter":{"title":"Avoid \\"REPLACE INTO\\"","authors":"ashish","date":"2025-12-29T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Designing L7 Load Balancer","permalink":"/docs/blog/load-balancer-design"},"nextItem":{"title":"Designing Slack\'s Realtime Communication System","permalink":"/docs/blog/slack-design"}}')},7048:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});var s=t(3047),r=t(4848),i=t(8453);const o={title:'Avoid "REPLACE INTO"',authors:"ashish",date:new Date("2025-12-29T00:00:00.000Z")},l=void 0,c={authorsImageUrls:[void 0]},a=[{value:"1. The &quot;Atomic&quot; Myth",id:"1-the-atomic-myth",level:2},{value:"2. The Locking Mechanism: Why Deadlocks Happen",id:"2-the-locking-mechanism-why-deadlocks-happen",level:2},{value:"The Gap Lock &amp; Next-Key Lock",id:"the-gap-lock--next-key-lock",level:3},{value:"The Deadlock Scenario",id:"the-deadlock-scenario",level:3},{value:"3. REPLACE vs. INSERT ON DUPLICATE KEY UPDATE",id:"3-replace-vs-insert-on-duplicate-key-update",level:2},{value:"Visualizing the Mechanics",id:"visualizing-the-mechanics",level:3},{value:"4. Does MySQL inherently handle concurrent upserts?",id:"4-does-mysql-inherently-handle-concurrent-upserts",level:2},{value:"What are the internal semantics?",id:"what-are-the-internal-semantics",level:3},{value:"5. Implementation Strategy",id:"5-implementation-strategy",level:2},{value:"Python Pseudo-code for Robust Upsert",id:"python-pseudo-code-for-robust-upsert",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In distributed systems, ",(0,r.jsx)(n.strong,{children:"Upsert"})," (Update or Insert) is a fundamental operation. You want to store a record: if it exists, update it; if not, create it."]}),"\n",(0,r.jsxs)(n.p,{children:["MySQL offers a deceptively simple command to handle this: ",(0,r.jsx)(n.code,{children:"REPLACE INTO"}),'. It looks like a standard insert, works like a charm in development, and satisfies the requirement of "single statement atomicity."']}),"\n",(0,r.jsxs)(n.p,{children:["However, under high concurrency, ",(0,r.jsx)(n.code,{children:"REPLACE INTO"})," can become a source of ",(0,r.jsx)(n.strong,{children:"deadlocks"}),", ",(0,r.jsx)(n.strong,{children:"latency spikes"}),", and ",(0,r.jsx)(n.strong,{children:"unexpected behavior"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In this post, we will tear apart the ",(0,r.jsx)(n.code,{children:"REPLACE"})," statement to understand its internal mechanics, how InnoDB handles locking, and why your client application ",(0,r.jsx)(n.strong,{children:"must"})," be prepared to handle concurrency explicitly."]}),"\n",(0,r.jsx)(n.h2,{id:"1-the-atomic-myth",children:'1. The "Atomic" Myth'}),"\n",(0,r.jsxs)(n.p,{children:["Developers often assume that because ",(0,r.jsx)(n.code,{children:"REPLACE INTO"}),' is a single SQL statement, it is a single atomic operation that effectively "locks" the row, does the job, and leaves.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The Reality:"}),"\nInternally, ",(0,r.jsx)(n.code,{children:"REPLACE INTO"})," is ",(0,r.jsx)(n.strong,{children:"not"})," a simple update. It is a destructive two-step process disguised as one."]}),"\n",(0,r.jsx)(n.admonition,{title:"How REPLACE works internally",type:"danger",children:(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check:"})," It attempts to insert the new row."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conflict:"})," If a Unique Key or Primary Key collision occurs:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Step A:"})," It performs a ",(0,r.jsx)(n.strong,{children:"DELETE"})," of the conflicting row."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Step B:"})," It performs a fresh ",(0,r.jsx)(n.strong,{children:"INSERT"})," of the new row."]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,r.jsx)(n.p,{children:'This "Delete + Insert" behavior has massive implications for locking and referential integrity.'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-the-locking-mechanism-why-deadlocks-happen",children:"2. The Locking Mechanism: Why Deadlocks Happen"}),"\n",(0,r.jsxs)(n.p,{children:["To understand why concurrent ",(0,r.jsx)(n.code,{children:"REPLACE"})," operations cause deadlocks, we need to look at ",(0,r.jsx)(n.strong,{children:"InnoDB Locking"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"the-gap-lock--next-key-lock",children:"The Gap Lock & Next-Key Lock"}),"\n",(0,r.jsx)(n.p,{children:"When you write to a table with a Unique Index, MySQL must ensure that no other transaction inserts a duplicate value while your transaction is running."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared Lock (S-Lock):"})," When ",(0,r.jsx)(n.code,{children:"REPLACE"})," detects a duplicate, it first acquires a ",(0,r.jsx)(n.em,{children:"Shared Lock"})," on the existing record to ensure it stays there while it decides what to do."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exclusive Lock (X-Lock):"})," To delete the old row and insert the new one, it must upgrade that lock to an ",(0,r.jsx)(n.em,{children:"Exclusive Lock"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"the-deadlock-scenario",children:"The Deadlock Scenario"}),"\n",(0,r.jsxs)(n.p,{children:["Imagine two clients (Transaction A and Transaction B) trying to ",(0,r.jsx)(n.code,{children:"REPLACE"})," the ",(0,r.jsx)(n.strong,{children:"same key"})," at the exact same time."]}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant TxA as Transaction A\n    participant DB as MySQL (InnoDB)\n    participant TxB as Transaction B\n\n    Note over TxA, TxB: Both try to REPLACE 'Key=100'\n    \n    TxA->>DB: REPLACE INTO ... VALUES (100)\n    DB--\x3e>TxA: Conflict Detected. Acquires S-Lock (Shared) on Key=100.\n    \n    TxB->>DB: REPLACE INTO ... VALUES (100)\n    DB--\x3e>TxB: Conflict Detected. Acquires S-Lock (Shared) on Key=100.\n    \n    Note over DB: Both hold S-Locks. Reading is fine.\n    \n    TxA->>DB: Attempts to DELETE Key=100 (Needs X-Lock)\n    Note over DB: TxA waits for TxB to release S-Lock.\n    \n    TxB->>DB: Attempts to DELETE Key=100 (Needs X-Lock)\n    Note over DB: TxB waits for TxA to release S-Lock.\n    \n    Note over TxA, TxB: \ud83d\udca5 DEADLOCK \ud83d\udca5\n    DB--\x3e>TxA: Error 1213: Deadlock found when trying to get lock"}),"\n",(0,r.jsx)(n.admonition,{title:"The Deadlock Trap",type:"warning",children:(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TxA"})," holds ",(0,r.jsx)(n.strong,{children:"S-Lock"}),". Wants ",(0,r.jsx)(n.strong,{children:"X-Lock"}),". Waits for ",(0,r.jsx)(n.strong,{children:"TxB"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TxB"})," holds ",(0,r.jsx)(n.strong,{children:"S-Lock"}),". Wants ",(0,r.jsx)(n.strong,{children:"X-Lock"}),". Waits for ",(0,r.jsx)(n.strong,{children:"TxA"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"InnoDB detects the cycle and kills one transaction (usually the smaller one) to break the deadlock."}),"\n"]})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Does MySQL inherently handle it?"}),"\nTechnically, yes\u2014by ",(0,r.jsx)(n.strong,{children:"killing"})," one of your requests. MySQL resolves the deadlock by forcing an error on one client. It does ",(0,r.jsx)(n.strong,{children:"not"})," queue them up nicely; it breaks the logjam with force."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Does the client need to handle it?"}),"\n",(0,r.jsx)(n.strong,{children:"YES."})," Your code ",(0,r.jsx)(n.strong,{children:"must"})," catch Error ",(0,r.jsx)(n.code,{children:"1213"})," and implement a retry logic."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-replace-vs-insert-on-duplicate-key-update",children:"3. REPLACE vs. INSERT ON DUPLICATE KEY UPDATE"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"REPLACE"})," is so dangerous, what should we use?\nThe industry standard alternative is ",(0,r.jsx)(n.code,{children:"INSERT ... ON DUPLICATE KEY UPDATE"})," (IODKU)."]}),"\n",(0,r.jsx)(n.p,{children:"Let's compare the internal semantics."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Feature"}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"REPLACE INTO"})}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"INSERT ON DUPLICATE ..."})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:"Mechanic"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"Delete + Insert"}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"Update"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:"Primary Key"})}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Changes"})," (New ID generated)"]}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Preserved"})," (ID stays same)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:"Foreign Keys"})}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Breaks"})," (Cascading Deletes triggered)"]}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,r.jsx)(n.strong,{children:"Safe"})," (References maintained)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:"Locking"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"Aggressive (Gap/Next-Key Locks)"}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"Moderate (Row Locks)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.strong,{children:"Deadlocks"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"High Probability"}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"Lower Probability (but non-zero)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"visualizing-the-mechanics",children:"Visualizing the Mechanics"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    subgraph REPLACE ["REPLACE INTO"]\n        R1[Try Insert] --\x3e R2{Conflict?}\n        R2 -- No --\x3e R3[Insert New Row]\n        R2 -- Yes --\x3e R4[DELETE Old Row]\n        R4 --\x3e R5[INSERT New Row]\n        style R4 fill:#ff9999,stroke:#333\n        style R5 fill:#99ff99,stroke:#333\n    end\n\n    subgraph IODKU ["INSERT ON DUPLICATE"]\n        I1[Try Insert] --\x3e I2{Conflict?}\n        I2 -- No --\x3e I3[Insert New Row]\n        I2 -- Yes --\x3e I4[UPDATE Existing Row]\n        style I4 fill:#99ccff,stroke:#333\n    end'}),"\n",(0,r.jsxs)(n.admonition,{title:"Pro Tip: Why IODKU is usually better",type:"tip",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"INSERT ON DUPLICATE KEY UPDATE"})," is non-destructive."]}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:'It performs a "logical" update.'}),"\n",(0,r.jsxs)(n.li,{children:["It does not churn your auto-increment IDs. ",(0,r.jsx)(n.code,{children:"REPLACE"}),' creates "holes" in your ID sequence because every update burns an ID.']}),"\n",(0,r.jsxs)(n.li,{children:["It avoids ",(0,r.jsx)(n.code,{children:"DELETE"})," triggers firing unexpectedly."]}),"\n"]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-does-mysql-inherently-handle-concurrent-upserts",children:"4. Does MySQL inherently handle concurrent upserts?"}),"\n",(0,r.jsxs)(n.p,{children:["MySQL handles ",(0,r.jsx)(n.strong,{children:"Data Integrity"})," (ACID) perfectly. It will never let two transactions corrupt the data. However, it handles concurrency by using ",(0,r.jsx)(n.strong,{children:"Locks"}),". When locks conflict cyclically, it handles it via ",(0,r.jsx)(n.strong,{children:"Deadlock Detection"})," (rolling back one transaction)."]}),"\n",(0,r.jsxs)(n.p,{children:["It does ",(0,r.jsx)(n.strong,{children:"not"}),' inherently "serialize" them without side effects. The side effect is the Deadlock Error.']}),"\n",(0,r.jsx)(n.h3,{id:"what-are-the-internal-semantics",children:"What are the internal semantics?"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gap Locks:"})," Even with ",(0,r.jsx)(n.code,{children:"READ COMMITTED"}),' isolation, unique constraint checks trigger Gap Locks or Next-Key Locks. This locks the "space" before and after the record.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lock Upgrades:"})," The transition from Shared (Read) to Exclusive (Write) is the danger zone."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-implementation-strategy",children:"5. Implementation Strategy"}),"\n",(0,r.jsxs)(n.p,{children:["If you are building a high-scale system, you should prefer ",(0,r.jsx)(n.code,{children:"INSERT ON DUPLICATE KEY UPDATE"}),". However, regardless of which statement you choose, you must implement a retry loop in your application code."]}),"\n",(0,r.jsx)(n.h3,{id:"python-pseudo-code-for-robust-upsert",children:"Python Pseudo-code for Robust Upsert"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'MAX_RETRIES = 3\n\ndef upsert_data(key, value):\n    retries = 0\n    while retries < MAX_RETRIES:\n        try:\n            # Prefer IODKU over REPLACE\n            cursor.execute("""\n                INSERT INTO store (`key`, `value`, `updated_at`) \n                VALUES (%s, %s, NOW())\n                ON DUPLICATE KEY UPDATE \n                `value` = VALUES(`value`), \n                `updated_at` = NOW()\n            """, (key, value))\n            \n            db.commit()\n            return # Success!\n            \n        except MySQLdb.OperationalError as e:\n            if e.args[0] == 1213: # Error Code: Deadlock found\n                retries += 1\n                time.sleep(0.1 * retries) # Exponential Backoff\n                continue\n            else:\n                raise e # Real error, re-raise\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Key Takeaway",type:"note",children:(0,r.jsxs)(n.p,{children:["At scale, ",(0,r.jsx)(n.strong,{children:"Database Deadlocks are not bugs; they are a fact of life."})," They are the database's way of protecting your data's consistency. Your application logic must be resilient enough to retry when they happen."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);