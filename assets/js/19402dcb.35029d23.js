"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6752],{3383:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var i=t(8538),o=t(4848),r=t(8453);const s={title:"Real-Time Communication with Server-Sent Events (SSE)",description:"A deep dive into Server-Sent Events, their use cases, protocol details, and a practical Python implementation.",slug:"server-sent-events-explained",authors:"ashish",date:new Date("2025-12-25T00:00:00.000Z")},a=void 0,l={authorsImageUrls:[void 0]},d=[{value:"1. What is Server-Sent Events (SSE)?",id:"1-what-is-server-sent-events-sse",level:2},{value:"2. Typical Use Cases",id:"2-typical-use-cases",level:2},{value:"3. The Protocol of Server-Sent Events",id:"3-the-protocol-of-server-sent-events",level:2},{value:"The Message Format",id:"the-message-format",level:3},{value:"Visualizing the Flow",id:"visualizing-the-flow",level:3},{value:"4. Implementation: Streaming Logs with Python",id:"4-implementation-streaming-logs-with-python",level:2},{value:"Key Components Explained",id:"key-components-explained",level:3},{value:"1. The Generator Function (<code>read_log_stream</code>)",id:"1-the-generator-function-read_log_stream",level:4},{value:"2. The Flask Response (<code>stream_log</code>)",id:"2-the-flask-response-stream_log",level:4},{value:"3. The Client (<code>index</code> route)",id:"3-the-client-index-route",level:4},{value:"The Code",id:"the-code",level:3}];function c(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["In the world of web development, the classic request-response model serves us well for most interactions. The client asks for data, and the server provides it. But what happens when the server has new data ",(0,o.jsx)(n.em,{children:"after"})," the initial request? How do we push updates to the client in real-time?"]}),"\n",(0,o.jsxs)(n.p,{children:["While WebSockets are a popular choice for bi-directional communication, they can be overkill for many scenarios. Enter ",(0,o.jsx)(n.strong,{children:"Server-Sent Events (SSE)"}),"\u2014a standard that allows servers to push data to web pages over a single HTTP connection."]}),"\n",(0,o.jsx)(n.p,{children:"In this post, we will explore what SSE is, typical use cases, the underlying protocol, and a practical implementation using Python and Flask."}),"\n",(0,o.jsx)(n.h2,{id:"1-what-is-server-sent-events-sse",children:"1. What is Server-Sent Events (SSE)?"}),"\n",(0,o.jsx)(n.p,{children:"Server-Sent Events (SSE) is a technology that enables a client (usually a browser) to receive automatic updates from a server via an HTTP connection. It creates a unidirectional channel: the client opens the connection, and the server keeps it open, pushing text-based messages whenever new data is available."}),"\n",(0,o.jsx)(n.p,{children:"Think of it like subscribing to a newsletter. You sign up once (the HTTP request), and the publisher sends you updates continuously as they happen, without you needing to ask for them again."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Key Characteristics:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unidirectional:"})," Server -> Client only."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Standard HTTP:"})," Works over standard HTTP/HTTPS."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Text-Based:"})," Sends data as UTF-8 text."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Automatic Reconnection:"})," Browsers automatically attempt to reconnect if the connection drops."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"2-typical-use-cases",children:"2. Typical Use Cases"}),"\n",(0,o.jsx)(n.p,{children:"Since SSE is unidirectional, it is perfect for scenarios where the client needs to be updated, but doesn't need to send high-frequency data back to the server."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Live Log Streaming:"})," Viewing server logs in real-time (as we will see in our example code)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Stock Tickers & Crypto Prices:"})," Updating dashboards with the latest financial data."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Progress Indicators:"})," Showing the progress of long-running tasks (e.g., file uploads, video processing)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sports Scores:"})," Live updates during a match."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"3-the-protocol-of-server-sent-events",children:"3. The Protocol of Server-Sent Events"}),"\n",(0,o.jsx)(n.p,{children:"SSE is deceptively simple. It sits on top of HTTP. Here is how the handshake and data transfer work:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The Request:"})," The client sends a standard GET request."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The Headers:"})," The server responds with specific headers to keep the connection open:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Content-Type: text/event-stream"})," (Crucial: tells the client to expect a stream)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Cache-Control: no-cache"})," (Prevents the browser from caching the stream)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Connection: keep-alive"})," (Keeps the TCP connection open)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The Payload:"})," The server sends data blocks separated by a pair of newlines (",(0,o.jsx)(n.code,{children:"\\n\\n"}),")."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"the-message-format",children:"The Message Format"}),"\n",(0,o.jsxs)(n.p,{children:["Each message in the stream is a block of text. The most common field is ",(0,o.jsx)(n.code,{children:"data"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"data: This is a message\n\ndata: This is the second message\n\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Note: In the raw protocol, every message must end with two newlines (",(0,o.jsx)(n.code,{children:"\\n\\n"}),") to signal the end of the event."]})}),"\n",(0,o.jsx)(n.p,{children:"You can also include event types and IDs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:'id: 101\nevent: update\ndata: {"status": "processing", "progress": 50}\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"visualizing-the-flow",children:"Visualizing the Flow"}),"\n",(0,o.jsx)(n.p,{children:"Here is a sequence diagram showing how the Client establishes the connection and receives a stream of log data."}),"\n",(0,o.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client: Step 1: Client initiates connection\n    Client->>Server: GET /api/logs/{id}/stream\n    \n    Note over Server: Step 2: Server accepts & keeps connection open\n    Server--\x3e>Client: 200 OK\n    Server--\x3e>Client: Content-Type: text/event-stream\n    \n    loop Stream Data\n        Note over Server: Log file updated\n        Server--\x3e>Client: data: [Log Line 1] (plus \\n\\n)\n        \n        Note over Server: Log file updated\n        Server--\x3e>Client: data: [Log Line 2] (plus \\n\\n)\n    end\n    \n    Note over Client, Server: Connection stays open indefinitely"}),"\n",(0,o.jsx)(n.h2,{id:"4-implementation-streaming-logs-with-python",children:"4. Implementation: Streaming Logs with Python"}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at a practical implementation. Below is a Python script using ",(0,o.jsx)(n.code,{children:"Flask"}),". It simulates a system where logs are being written to a file in the background, and a client listens to these logs in real-time via SSE."]}),"\n",(0,o.jsx)(n.h3,{id:"key-components-explained",children:"Key Components Explained"}),"\n",(0,o.jsx)(n.p,{children:"There are two critical parts in the code that make SSE work:"}),"\n",(0,o.jsxs)(n.h4,{id:"1-the-generator-function-read_log_stream",children:["1. The Generator Function (",(0,o.jsx)(n.code,{children:"read_log_stream"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["Standard HTTP requests return a block of data and close. To stream, Python uses ",(0,o.jsx)(n.strong,{children:"generators"})," (functions that ",(0,o.jsx)(n.code,{children:"yield"})," instead of ",(0,o.jsx)(n.code,{children:"return"}),")."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def read_log_stream(log_id: str):\n    # ... setup code ...\n    while True:\n        # Check for new data\n        if new_lines:\n             for line in new_lines:\n                 # Format specifically for SSE\n                 yield f"data: {line.rstrip()}\\n\\n"\n        else:\n             # Wait briefly to prevent 100% CPU usage\n             time.sleep(0.1)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This function keeps running. Every time it finds a new line in the log file, it pushes it out using ",(0,o.jsx)(n.code,{children:"yield"}),"."]}),"\n",(0,o.jsxs)(n.h4,{id:"2-the-flask-response-stream_log",children:["2. The Flask Response (",(0,o.jsx)(n.code,{children:"stream_log"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["Flask needs to know this isn't a normal response. We pass the generator function to ",(0,o.jsx)(n.code,{children:"Response"})," and set the headers."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'@app.route("/api/logs/<log_id>/stream", methods=["GET"])\ndef stream_log(log_id: str):\n    return Response(\n        read_log_stream(log_id),\n        mimetype="text/event-stream",  # Required for SSE\n        headers={\n            "Cache-Control": "no-cache", # Prevent buffering\n            "Connection": "keep-alive"   # Keep connection open\n        }\n    )\n'})}),"\n",(0,o.jsxs)(n.h4,{id:"3-the-client-index-route",children:["3. The Client (",(0,o.jsx)(n.code,{children:"index"})," route)"]}),"\n",(0,o.jsxs)(n.p,{children:["On the frontend (embedded in the ",(0,o.jsx)(n.code,{children:"index"})," function), the ",(0,o.jsx)(n.code,{children:"EventSource"})," API handles the heavy lifting."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'eventSource = new EventSource(`/api/logs/${logId}/stream`);\n\neventSource.onmessage = function(event) {\n    // This runs every time the server sends a "data:" packet\n    console.log("New Log:", event.data);\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"SSE Log Streaming",src:t(4284).A+"",width:"1200",height:"655"})}),"\n",(0,o.jsx)(n.p,{children:"SSE is a powerful tool in your system design toolkit. While it doesn't replace WebSockets for complex bidirectional needs (like a chat app), it is often the simpler, more efficient choice for one-way updates."}),"\n",(0,o.jsx)(n.h3,{id:"the-code",children:"The Code"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import time\nimport threading\nimport uuid\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom flask import Flask, request, Response\nfrom faker import Faker\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\'\n)\nlogger = logging.getLogger(__name__)\n\napp = Flask(__name__)\nfake = Faker()\n\n# Directory to store log files\nLOG_DIR = Path("../logs")\nLOG_DIR.mkdir(exist_ok=True)\nlogger.info(f"Log directory set to: {LOG_DIR.absolute()}")\n\n# Track active log streams\nactive_streams = {}\n\n\ndef generate_random_text():\n    """Generate random text using Faker"""\n    choices = [\n        lambda: fake.sentence(),\n        lambda: fake.paragraph(),\n        lambda: fake.word(),\n        lambda: f"[{datetime.now().isoformat()}] {fake.sentence()}",\n    ]\n    text = choices[id(time.time()) % len(choices)]()\n    logger.debug(f"Generated random text: {text[:50]}...")\n    return text\n\n\ndef write_to_log(log_id: str, message: str):\n    """Write a message to the log file"""\n    log_file = LOG_DIR / f"{log_id}.log"\n    try:\n        with open(log_file, "a") as f:\n            f.write(message + "\\n")\n        logger.debug(f"Wrote to log {log_id}: {message[:50]}...")\n    except IOError as e:\n        logger.error(f"Failed to write to log {log_id}: {e}")\n\n\ndef simulate_log_writing(log_id: str, duration: int = 30):\n    """Simulate writing to log file for a given duration"""\n    logger.info(f"Starting log writing thread for log_id={log_id}, duration={duration}s")\n    end_time = time.time() + duration\n    write_count = 0\n\n    while time.time() < end_time:\n        message = generate_random_text()\n        write_to_log(log_id, message)\n        write_count += 1\n        time.sleep(0.5)  # Write every 500ms\n\n    logger.info(f"Finished log writing for log_id={log_id}. Total lines written: {write_count}")\n\n\ndef read_log_stream(log_id: str):\n    """Generator that streams log content"""\n    log_file = LOG_DIR / f"{log_id}.log"\n    logger.info(f"Starting log stream for log_id={log_id}")\n\n    if not log_file.exists():\n        logger.warning(f"Log file not found for log_id={log_id}")\n        yield f"data: Log file {log_id} not found\\n\\n"\n        return\n\n    # Start reading from beginning\n    position = 0\n    line_count = 0\n\n    while True:\n        try:\n            with open(log_file, "r") as f:\n                f.seek(position)\n                lines = f.readlines()\n\n                if lines:\n                    for line in lines:\n                        # Protocol: Prefix with "data: " and end with double newline\n                        yield f"data: {line.rstrip()}\\n\\n"\n                        line_count += 1\n                    position = f.tell()\n                    logger.debug(f"Streamed {len(lines)} lines for log_id={log_id}, position={position}")\n                else:\n                    # No new data, check if log is still being written\n                    # In a real app, you might have a mechanism to break if the process is dead\n                    logger.debug(f"No new data for log_id={log_id}, waiting...")\n                    time.sleep(0.1)\n        except IOError as e:\n            logger.error(f"Error reading log file for log_id={log_id}: {e}")\n            yield f"data: Error reading log file\\n\\n"\n            break\n\n    logger.info(f"Finished streaming log_id={log_id}. Total lines streamed: {line_count}")\n\n\n@app.route("/api/logs", methods=["POST"])\ndef create_log():\n    """\n    Create a new log file and start streaming random content to it.\n    Returns the log ID for later reference.\n    """\n    log_id = str(uuid.uuid4())\n    log_file = LOG_DIR / f"{log_id}.log"\n\n    logger.info(f"Creating new log with log_id={log_id}")\n\n    # Create empty log file\n    log_file.touch()\n    logger.debug(f"Log file created at: {log_file.absolute()}")\n\n    # Write initial message\n    write_to_log(log_id, f"[LOG CREATED] {datetime.now().isoformat()}")\n\n    # Start background thread to write random content\n    duration = request.args.get("duration", 30, type=int)\n    logger.info(f"Starting background thread for log_id={log_id} with duration={duration}s")\n\n    thread = threading.Thread(\n        target=simulate_log_writing,\n        args=(log_id, duration),\n        daemon=True\n    )\n    thread.start()\n    logger.debug(f"Thread started for log_id={log_id}")\n\n    return {\n        "log_id": log_id,\n        "message": f"Log file created with ID: {log_id}",\n        "stream_url": f"/api/logs/{log_id}/stream"\n    }, 201\n\n\n@app.route("/api/logs/<log_id>/stream", methods=["GET"])\ndef stream_log(log_id: str):\n    """\n    Stream the log file content using Server-Sent Events.\n    Reads from the beginning and continuously streams new content.\n    """\n    logger.info(f"Stream request received for log_id={log_id}")\n    log_file = LOG_DIR / f"{log_id}.log"\n\n    if not log_file.exists():\n        logger.warning(f"Stream request for non-existent log_id={log_id}")\n        def error_stream():\n            yield f"data: Log file {log_id} not found\\n\\n"\n        return Response(error_stream(), mimetype="text/event-stream")\n\n    logger.debug(f"Starting SSE stream for log_id={log_id}")\n    return Response(\n        read_log_stream(log_id),\n        mimetype="text/event-stream",\n        headers={\n            "Cache-Control": "no-cache",\n            "X-Accel-Buffering": "no",\n            "Connection": "keep-alive"\n        }\n    )\n\n\n@app.route("/api/logs/<log_id>", methods=["GET"])\ndef get_log_info(log_id: str):\n    """Get information about a specific log file"""\n    logger.info(f"Info request received for log_id={log_id}")\n    log_file = LOG_DIR / f"{log_id}.log"\n\n    if not log_file.exists():\n        logger.warning(f"Info request for non-existent log_id={log_id}")\n        return {"error": f"Log file {log_id} not found"}, 404\n\n    file_size = log_file.stat().st_size\n    created_at = datetime.fromtimestamp(log_file.stat().st_ctime).isoformat()\n    logger.debug(f"Log info for log_id={log_id}: size={file_size}, created={created_at}")\n\n    return {\n        "log_id": log_id,\n        "file_size": file_size,\n        "created_at": created_at,\n        "stream_url": f"/api/logs/{log_id}/stream"\n    }, 200\n\n\n@app.route("/", methods=["GET"])\ndef index():\n    """Serve a simple HTML client for testing"""\n    return """\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <title>Log Streaming PoC</title>\n        <style>\n            body { font-family: monospace; margin: 20px; }\n            button { padding: 10px 20px; margin: 10px 0; cursor: pointer; }\n            #log-container { \n                border: 1px solid #ccc; \n                padding: 10px; \n                height: 400px; \n                overflow-y: auto; \n                background: #f5f5f5;\n                margin: 10px 0;\n            }\n            .log-line { margin: 2px 0; }\n            .status { padding: 10px; border-radius: 5px; margin: 10px 0; }\n            .status.success { background: #d4edda; color: #155724; }\n            .status.error { background: #f8d7da; color: #721c24; }\n        </style>\n    </head>\n    <body>\n        <h1>Log Streaming Proof of Concept</h1>\n        \n        <div>\n            <button onclick="createLog()">Create New Log</button>\n            <input type="number" id="duration" placeholder="Duration (seconds)" value="30" min="5" max="300">\n        </div>\n        \n        <div id="status"></div>\n        \n        <div>\n            Log ID: <input type="text" id="log-id" placeholder="Enter log ID or create new">\n            <button onclick="startStream()">Start Streaming</button>\n            <button onclick="stopStream()">Stop Streaming</button>\n        </div>\n        \n        <div id="log-container"></div>\n        \n        <script>\n            let eventSource = null;\n            \n            async function createLog() {\n                const duration = document.getElementById(\'duration\').value;\n                const statusDiv = document.getElementById(\'status\');\n                \n                try {\n                    const response = await fetch(\'/api/logs?duration=\' + duration, { method: \'POST\' });\n                    const data = await response.json();\n                    \n                    document.getElementById(\'log-id\').value = data.log_id;\n                    statusDiv.innerHTML = `<div class="status success">\u2713 Log created: ${data.log_id}</div>`;\n                    \n                    // Auto-start streaming\n                    setTimeout(() => startStream(), 500);\n                } catch (error) {\n                    statusDiv.innerHTML = `<div class="status error">\u2717 Error: ${error.message}</div>`;\n                }\n            }\n            \n            function startStream() {\n                const logId = document.getElementById(\'log-id\').value;\n                const statusDiv = document.getElementById(\'status\');\n                \n                if (!logId) {\n                    statusDiv.innerHTML = \'<div class="status error">\u2717 Please create or enter a log ID</div>\';\n                    return;\n                }\n                \n                if (eventSource) {\n                    eventSource.close();\n                }\n                \n                const logContainer = document.getElementById(\'log-container\');\n                logContainer.innerHTML = \'\';\n                \n                eventSource = new EventSource(`/api/logs/${logId}/stream`);\n                statusDiv.innerHTML = `<div class="status success">\u2713 Streaming logs...</div>`;\n                \n                eventSource.onmessage = function(event) {\n                    const line = document.createElement(\'div\');\n                    line.className = \'log-line\';\n                    line.textContent = event.data;\n                    logContainer.appendChild(line);\n                    logContainer.scrollTop = logContainer.scrollHeight;\n                };\n                \n                eventSource.onerror = function(error) {\n                    statusDiv.innerHTML = \'<div class="status error">\u2717 Streaming stopped</div>\';\n                    eventSource.close();\n                };\n            }\n            \n            function stopStream() {\n                if (eventSource) {\n                    eventSource.close();\n                    eventSource = null;\n                }\n                document.getElementById(\'status\').innerHTML = \'<div class="status">Streaming stopped</div>\';\n            }\n        <\/script>\n    </body>\n    </html>\n    """, 200\n\n\nif __name__ == "__main__":\n    logger.info("=" * 60)\n    logger.info("Starting Log Streaming PoC Service...")\n    logger.info("=" * 60)\n    print("Starting Log Streaming PoC Service...")\n    print("Open http://localhost:5000 in your browser")\n    logger.info("Service listening on [http://127.0.0.1:5000](http://127.0.0.1:5000)")\n    app.run(debug=True, port=5000)\n'})})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},4284:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/sse-log-streaming-caefd8e16af0df04da8755099ff10960.png"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},8538:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/server-sent-events-explained","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/server-sent-event.md","source":"@site/blog/server-sent-event.md","title":"Real-Time Communication with Server-Sent Events (SSE)","description":"A deep dive into Server-Sent Events, their use cases, protocol details, and a practical Python implementation.","date":"2025-12-25T00:00:00.000Z","tags":[],"readingTime":9.69,"hasTruncateMarker":false,"authors":[{"name":"Ashish Rathod","title":"Ex-Intuit Staff Engineer","url":"https://www.linkedin.com/in/ashish-rathod02/","page":{"permalink":"/docs/blog/authors/ashish"},"socials":{"linkedin":"https://www.linkedin.com/in/ashish-rathod02/","github":"https://github.com/arathod02"},"imageURL":"https://github.com/arathod02.png","key":"ashish"}],"frontMatter":{"title":"Real-Time Communication with Server-Sent Events (SSE)","description":"A deep dive into Server-Sent Events, their use cases, protocol details, and a practical Python implementation.","slug":"server-sent-events-explained","authors":"ashish","date":"2025-12-25T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Scaling Databases with Proxy Servers","permalink":"/docs/blog/proxy-server"},"nextItem":{"title":"Implementing Shard Aware Application","permalink":"/docs/blog/application-level-sharding-design"}}')}}]);