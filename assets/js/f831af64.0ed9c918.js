"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9990],{692:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var i=s(4198),t=s(4848),r=s(8453);const l={slug:"offline-online-indicator",title:"Design an Online/Offline Indicator (Presence Service)",sidebar_label:"Presence Service",description:"Designing a scalable presence system for 1 billion users.",authors:"ashish"},a=void 0,o={authorsImageUrls:[void 0]},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"High-Level Strategy: Push vs. Pull",id:"high-level-strategy-push-vs-pull",level:2},{value:"Option 1: Pull (Polling)",id:"option-1-pull-polling",level:3},{value:"Option 2: Push (Heartbeat)",id:"option-2-push-heartbeat",level:3},{value:"The Protocol: HTTP vs. WebSockets",id:"the-protocol-http-vs-websockets",level:2},{value:"1. REST/HTTP Based",id:"1-resthttp-based",level:3},{value:"2. Persistent WebSockets",id:"2-persistent-websockets",level:3},{value:"Database Design &amp; Estimation",id:"database-design--estimation",level:2},{value:"Query Patterns",id:"query-patterns",level:3},{value:"Data Schema",id:"data-schema",level:3},{value:"Capacity Planning",id:"capacity-planning",level:3},{value:"Managing &quot;Online&quot; State Lifecycle",id:"managing-online-state-lifecycle",level:2},{value:"1. The Cron Job Reaper",id:"1-the-cron-job-reaper",level:3},{value:"2. Connection Events (Explicit Disconnect)",id:"2-connection-events-explicit-disconnect",level:3},{value:"3. Database TTL (Time-To-Live)",id:"3-database-ttl-time-to-live",level:3},{value:"Database Selection: Redis vs. DynamoDB",id:"database-selection-redis-vs-dynamodb",level:2},{value:"Candidate 1: Amazon DynamoDB",id:"candidate-1-amazon-dynamodb",level:3},{value:"Candidate 2: Redis (The Winner)",id:"candidate-2-redis-the-winner",level:3},{value:"Final Architecture",id:"final-architecture",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Designing a system to indicate if a user is ",(0,t.jsx)(n.strong,{children:"Online"})," or ",(0,t.jsx)(n.strong,{children:"Offline"})," (and their last seen timestamp) sounds simple on the surface, but becomes a massive engineering challenge when scaling to ",(0,t.jsx)(n.strong,{children:"1 Billion users"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"In this post, we will breakdown the design of a Presence Service suitable for a massive social network or chat application like WhatsApp or Facebook Messenger."}),"\n",(0,t.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsx)(n.p,{children:"We need to build a service that indicates the availability status of a user's connections."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Functional Requirements:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Indicate if a friend/connection is currently ",(0,t.jsx)(n.strong,{children:"Online"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If offline, display the ",(0,t.jsx)(n.strong,{children:"Last Seen"})," timestamp."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Scale:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Total Users:"})," ~1 Billion."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Concurrent Online Users:"})," ~500 Million."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Latency:"})," The status needs to be near real-time."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"high-level-strategy-push-vs-pull",children:"High-Level Strategy: Push vs. Pull"}),"\n",(0,t.jsx)(n.p,{children:"How do we keep the server updated about the client's status?"}),"\n",(0,t.jsx)(n.h3,{id:"option-1-pull-polling",children:"Option 1: Pull (Polling)"}),"\n",(0,t.jsx)(n.p,{children:'The server periodically connects to the client to ask, "Are you there?"'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verdict:"})," \u274c ",(0,t.jsx)(n.strong,{children:"Impossible."})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reasoning:"})," In a mobile/NAT environment, servers cannot initiate connections to clients easily. Furthermore, polling 1B users is computationally wasteful."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"option-2-push-heartbeat",children:"Option 2: Push (Heartbeat)"}),"\n",(0,t.jsx)(n.p,{children:'The client sends a signal to the server periodically saying, "I am alive."'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verdict:"})," \u2705 ",(0,t.jsx)(n.strong,{children:"Selected."})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reasoning:"})," This is the standard pattern for presence. If the server stops receiving heartbeats (after a timeout threshold), the user is marked offline."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"the-protocol-http-vs-websockets",children:"The Protocol: HTTP vs. WebSockets"}),"\n",(0,t.jsx)(n.p,{children:'We established a "Push" model, but how should the client push this data?'}),"\n",(0,t.jsx)(n.h3,{id:"1-resthttp-based",children:"1. REST/HTTP Based"}),"\n",(0,t.jsxs)(n.p,{children:["The client sends a ",(0,t.jsx)(n.code,{children:"POST /health"})," request every ",(0,t.jsx)(n.em,{children:"N"})," seconds."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this fails at scale:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Overhead:"})," HTTP is stateless. Every heartbeat requires a full 3-way TCP handshake (if not using keep-alive efficiently), SSL handshake overhead, and heavy HTTP headers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Traffic:"})," With 500M concurrent users sending a heartbeat every 10 seconds, that is ",(0,t.jsx)(n.strong,{children:"50 Million requests per second"}),". Most of the data transferred would be HTTP headers, not the actual status payload."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-persistent-websockets",children:"2. Persistent WebSockets"}),"\n",(0,t.jsx)(n.p,{children:"The client opens a long-lived, bi-directional connection with the server."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this is the winner:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Overhead:"})," Once the connection is established, data frames have minimal overhead (just a few bytes). There are no repeated headers or handshakes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time:"})," The server knows ",(0,t.jsx)(n.em,{children:"immediately"})," if a connection is severed (TCP FIN or RST)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bi-directional:"})," It allows the server to push status updates of ",(0,t.jsx)(n.em,{children:"friends"})," back to the user over the same channel."]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{title:'The "Disconnect" Fallacy',type:"caution",children:[(0,t.jsxs)(n.p,{children:["A common misconception is that WebSockets natively handle all disconnects via an ",(0,t.jsx)(n.code,{children:"onDisconnect"})," event."]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clean Disconnect:"}),' If a user clicks "Logout", the client sends a TCP FIN. The server knows immediately.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dirty Disconnect:"})," If the user loses internet connectivity or the connection is broken for any reason, ",(0,t.jsx)(n.strong,{children:"the server receives nothing."})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Fix:"})," We must implement an ",(0,t.jsx)(n.strong,{children:"Application-Level Heartbeat"}),'. If the server doesn\'t receive a "Ping" frame or message within $N$ seconds, it forcibly closes the socket and marks the user offline.']}),"\n"]})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Scaling WebSockets",type:"info",children:[(0,t.jsx)(n.p,{children:"Scaling persistent connections is harder than scaling stateless HTTP."}),(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OS Limits:"})," You must tune the kernel to allow >65k open file descriptors (ephemeral ports) per server."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Load Balancing:"}),' You need a Layer 7 Load Balancer that supports "Sticky Sessions" effectively, though for a pure presence service, state can be externalized.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory:"})," Holding 500M open connections requires massive RAM across your fleet of connection handlers (Gateway Service)."]}),"\n"]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"database-design--estimation",children:"Database Design & Estimation"}),"\n",(0,t.jsxs)(n.p,{children:["The compute layer is pretty. All it has to do is upon receiving the request, perform a key value based insert or lookup and simply return back to the client. The complexity lies in the ",(0,t.jsx)(n.strong,{children:"storage layer"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"query-patterns",children:"Query Patterns"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Write (Heavy):"})," Update User ",(0,t.jsx)(n.em,{children:"A"}),"'s timestamp (Heartbeat)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read (Heavy):"})," Get status for User ",(0,t.jsx)(n.em,{children:"A"}),"'s friends/connections when User ",(0,t.jsx)(n.em,{children:"A"})," opens the app."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"data-schema",children:"Data Schema"}),"\n",(0,t.jsx)(n.p,{children:"We need a simple Key-Value pair."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Field"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,t.jsx)(n.th,{children:"Size"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"UserID"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Integer"}),(0,t.jsx)(n.td,{children:"4 Bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"LastSeen"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Epoch (Int)"}),(0,t.jsx)(n.td,{children:"4 Bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Total"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"}}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"8 Bytes"})})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"capacity-planning",children:"Capacity Planning"}),"\n",(0,t.jsx)(n.p,{children:"With 1 Billion users, do we need massive storage?"}),"\n",(0,t.jsx)(n.p,{children:"1,000,000,000 users * 8 bytes = 8 GB"}),"\n",(0,t.jsx)(n.admonition,{title:"Insight",type:"tip",children:(0,t.jsxs)(n.p,{children:["We only need ",(0,t.jsx)(n.strong,{children:"~8 GB"})," of storage to hold the state of every user on the planet. This entire dataset can fit into the RAM of a single modern server instance."]})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"managing-online-state-lifecycle",children:'Managing "Online" State Lifecycle'}),"\n",(0,t.jsx)(n.p,{children:"How do we decide when to switch a user from Online to Offline? We have three strategies."}),"\n",(0,t.jsx)(n.h3,{id:"1-the-cron-job-reaper",children:"1. The Cron Job Reaper"}),"\n",(0,t.jsx)(n.p,{children:"A background process scans the database every few minutes and deletes entries older than $N$ minutes."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Keeps DB clean eventually."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cons:"})," ",(0,t.jsx)(n.strong,{children:"Terrible at scale."}),' Scanning a table of 500M rows every minute creates massive read pressure and locking issues. The "Offline" status will always be laggy.']}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-connection-events-explicit-disconnect",children:"2. Connection Events (Explicit Disconnect)"}),"\n",(0,t.jsxs)(n.p,{children:["Leverage WebSocket callbacks (",(0,t.jsx)(n.code,{children:"onConnect"}),", ",(0,t.jsx)(n.code,{children:"onDisconnect"}),") to update the DB."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," extremely efficient. Writes only happen on state changes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cons:"})," Unreliable. If a user loses network (enters a tunnel) or the app crashes, the ",(0,t.jsx)(n.code,{children:"onDisconnect"}),' event might never fire sent to the server. The user will appear "Online" forever (a Zombie session).']}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-database-ttl-time-to-live",children:"3. Database TTL (Time-To-Live)"}),"\n",(0,t.jsx)(n.p,{children:"Use the database's native feature to auto-expire keys. The Heartbeat simply resets the TTL."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pros:"}),' Handles "unclean" disconnects gracefully. If the heartbeat stops, the key vanishes automatically. No manual cleanup required.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cons:"})," Moderate write load (every heartbeat is a write to reset the TTL)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Verdict:"})," We will use ",(0,t.jsx)(n.strong,{children:"Option 3 (TTL)"})," as the primary mechanism, potentially optimized by Option 2 (explicitly deleting the key on a clean logout to avoid the TTL wait)."]}),"\n",(0,t.jsx)(n.h2,{id:"database-selection-redis-vs-dynamodb",children:"Database Selection: Redis vs. DynamoDB"}),"\n",(0,t.jsx)(n.p,{children:"We need a Key-Value store that handles massive write throughput."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Math:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"500 Million concurrent users."}),"\n",(0,t.jsx)(n.li,{children:"Heartbeat interval: 30 seconds."}),"\n",(0,t.jsxs)(n.li,{children:["Throughput = $500,000,000 / 30 \\approx$ ",(0,t.jsx)(n.strong,{children:"16.6 Million Writes/Second"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"candidate-1-amazon-dynamodb",children:"Candidate 1: Amazon DynamoDB"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pros:"})," Serverless, high durability, multi-region replication (Global Tables)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cons:"})," ",(0,t.jsx)(n.strong,{children:"Cost and Hot Partitions."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Cost: DynamoDB charges by ",(0,t.jsx)(n.strong,{children:"Write Capacity Units (WCUs)"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["16.6 Million writes/sec = ",(0,t.jsx)(n.strong,{children:"16.6 Million WCUs"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Cost per WCU (Provisioned) $\\approx $0.00065$ / hour."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hourly Cost:"})," $$10,833$."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monthly Cost:"})," ",(0,t.jsx)(n.strong,{children:"~$7.9 Million / Month"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Hot Partition: In DynamoDB, a single partition is strictly limited to ",(0,t.jsx)(n.strong,{children:"1,000 WCUs"}),". If 2,000 users map to the same partition key, requests get throttled."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"candidate-2-redis-the-winner",children:"Candidate 2: Redis (The Winner)"}),"\n",(0,t.jsx)(n.p,{children:"Redis is an in-memory store. We are limited by CPU/Network throughput per node."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pros:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"In-Memory Speed:"})," Sub-millisecond reads/writes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Native TTL:"})," Redis handles key expiration natively and efficiently."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost Effective:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Redis is an in-memory store. We are limited by CPU/Network throughput per node."}),"\n",(0,t.jsxs)(n.li,{children:["A single robust Redis node (e.g., AWS ",(0,t.jsx)(n.code,{children:"r7g.xlarge"}),") can handle ",(0,t.jsx)(n.strong,{children:"~600,000 writes/sec"}),". (",(0,t.jsx)(n.strong,{children:"Benchmark"}),": ",(0,t.jsx)(n.a,{href:"https://aws.plainenglish.io/aws-elasticache-a-performance-and-cost-analysis-of-redis-7-1-vs-valkey-7-2-bfac4fb5c22a",children:"https://aws.plainenglish.io/aws-elasticache-a-performance-and-cost-analysis-of-redis-7-1-vs-valkey-7-2-bfac4fb5c22a"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Nodes required: $16,600,000 / 600,000 \\approx$ ",(0,t.jsx)(n.strong,{children:"28 Shards"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Cost per node $\\approx $0.30$ / hour."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monthly Cost:"})," $28 * $0.30 * 730 hours = ",(0,t.jsx)(n.strong,{children:"~$6132 / Month"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cons:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"}),' If Redis crashes, we lose "Last Seen" data (unless AOF mode is enabled, which slows performance).']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mitigation:"})," For a Presence system, ",(0,t.jsx)(n.em,{children:"ephemeral"})," data loss is acceptable. If Redis crashes, users briefly appear offline until their next heartbeat (seconds later)."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Cost Epiphany",type:"tip",children:(0,t.jsxs)(n.p,{children:["By choosing Redis over DynamoDB for this high-throughput/ephemeral workload, we save the company roughly ",(0,t.jsx)(n.strong,{children:"$7.89 Million per month"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"final-architecture",children:"Final Architecture"}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart TD\n    Client[User Client] --\x3e|WebSocket Connection| LB[Load Balancer]\n    LB --\x3e|Sticky Session| WS[WebSocket Server]\n    \n    subgraph Data Layer\n    WS --\x3e|HEARTBEAT every 10s| Redis[(Redis Cluster)]\n    end\n    \n    note[Redis Key: UserID <br/> Value: Timestamp <br/> TTL: 30s] -.-> Redis"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},4198:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/offline-online-indicator","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/presence-design.md","source":"@site/blog/presence-design.md","title":"Design an Online/Offline Indicator (Presence Service)","description":"Designing a scalable presence system for 1 billion users.","date":"2025-12-10T10:55:15.000Z","tags":[],"readingTime":6.08,"hasTruncateMarker":false,"authors":[{"name":"Ashish Rathod","title":"Ex-Intuit Staff Engineer","url":"https://www.linkedin.com/in/ashish-rathod02/","page":{"permalink":"/docs/blog/authors/ashish"},"socials":{"linkedin":"https://www.linkedin.com/in/ashish-rathod02/","github":"https://github.com/arathod02"},"imageURL":"https://github.com/arathod02.png","key":"ashish"}],"frontMatter":{"slug":"offline-online-indicator","title":"Design an Online/Offline Indicator (Presence Service)","sidebar_label":"Presence Service","description":"Designing a scalable presence system for 1 billion users.","authors":"ashish"},"unlisted":false,"prevItem":{"title":"The Thundering Herd - Understanding and Solving the Cache Stampede","permalink":"/docs/blog/cache-stampede-thundering-herd"}}')},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);