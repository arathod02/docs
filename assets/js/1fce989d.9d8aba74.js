"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2246],{5021:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/application-level-sharding-design","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/shard-aware-app-design.md","source":"@site/blog/shard-aware-app-design.md","title":"Implementing Shard Aware Application","description":"In my previous post, we explored the high-level strategies for scaling databases, touching upon vertical scaling, read replicas, and finally, sharding. Today, I want to double-click on Sharding, specifically focusing on the Application-Level Sharding strategy.","date":"2025-12-14T00:00:00.000Z","tags":[],"readingTime":4.47,"hasTruncateMarker":false,"authors":[{"name":"Ashish Rathod","title":"Ex-Intuit Staff Engineer","url":"https://www.linkedin.com/in/ashish-rathod02/","page":{"permalink":"/docs/blog/authors/ashish"},"socials":{"linkedin":"https://www.linkedin.com/in/ashish-rathod02/","github":"https://github.com/arathod02"},"imageURL":"https://github.com/arathod02.png","key":"ashish"}],"frontMatter":{"title":"Implementing Shard Aware Application","slug":"application-level-sharding-design","authors":"ashish","date":"2025-12-14T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Real-Time Communication with Server-Sent Events (SSE)","permalink":"/docs/blog/server-sent-events-explained"},"nextItem":{"title":"Scaling Distributed Systems (Focus on Databases)","permalink":"/docs/blog/scaling-distributed-systems"}}')},8034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=t(5021),i=t(4848),s=t(8453);const o={title:"Implementing Shard Aware Application",slug:"application-level-sharding-design",authors:"ashish",date:new Date("2025-12-14T00:00:00.000Z")},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Metadata Control Plane",id:"the-metadata-control-plane",level:2},{value:"1. Database Metadata",id:"1-database-metadata",level:3},{value:"2. Tenant Metadata",id:"2-tenant-metadata",level:3},{value:"The Logical Relationship",id:"the-logical-relationship",level:3},{value:"The Bootup Sequence: <code>initializeDB()</code>",id:"the-bootup-sequence-initializedb",level:2},{value:"Runtime Request Handling: <code>getConnection(tenantId)</code>",id:"runtime-request-handling-getconnectiontenantid",level:2},{value:"The Strategic Benefits",id:"the-strategic-benefits",level:2},{value:"1. Logical Representation of Infrastructure",id:"1-logical-representation-of-infrastructure",level:3},{value:"2. Logical Mapping &amp; Zero-Downtime Migration",id:"2-logical-mapping--zero-downtime-migration",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In my previous post, we explored the high-level strategies for scaling databases, touching upon vertical scaling, read replicas, and finally, sharding. Today, I want to double-click on ",(0,i.jsx)(n.strong,{children:"Sharding"}),", specifically focusing on the ",(0,i.jsx)(n.strong,{children:"Application-Level Sharding"})," strategy."]}),"\n",(0,i.jsx)(n.p,{children:'We often talk about "making the application shard-aware," but what does that look like in code? How do we manage thousands of connections without overwhelming the application or the database? How do we handle re-sharding without downtime?'}),"\n",(0,i.jsxs)(n.p,{children:["In this post, I will walk you through a battle-tested architecture we implemented at a previous organization, where we managed multi-tenant data at scale using a custom ",(0,i.jsx)(n.strong,{children:"Data Access Layer (DAL)"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"the-metadata-control-plane",children:"The Metadata Control Plane"}),"\n",(0,i.jsxs)(n.p,{children:["To build a robust shard-aware application, you cannot hardcode connection strings or shard logic. You need a dynamic ",(0,i.jsx)(n.strong,{children:"Control Plane"}),". We solved this by externalizing our topology into two DynamoDB tables."]}),"\n",(0,i.jsx)(n.h3,{id:"1-database-metadata",children:"1. Database Metadata"}),"\n",(0,i.jsxs)(n.p,{children:["This table acts as the source of truth for the physical infrastructure. It decouples the ",(0,i.jsx)(n.em,{children:"logical"})," definition of a database from its ",(0,i.jsx)(n.em,{children:"physical"})," connection details."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key:"})," ",(0,i.jsx)(n.code,{children:"ShardName"})," + ",(0,i.jsx)(n.code,{children:"DatabaseName"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Attributes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ConnectionDetails"})," (JSON): Contains endpoints for different use cases (Write, Read, Analytics), credentials, and schema names."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CapacityMetrics"}),": Tracks the current load (e.g., number of Small/Medium/Large tenants) to aid in placement decisions for new tenants."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-tenant-metadata",children:"2. Tenant Metadata"}),"\n",(0,i.jsx)(n.p,{children:"This table serves as the routing directory. It maps a specific tenant to a logical shard."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key:"})," ",(0,i.jsx)(n.code,{children:"TenantID"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Attributes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ShardName"}),": The logical shard where this tenant resides."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DatabaseName"}),": The specific database instance within that shard."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-logical-relationship",children:"The Logical Relationship"}),"\n",(0,i.jsx)(n.p,{children:"By splitting these concerns, we create a normalized view of our topology. The Tenant Metadata points to a logical location, and the Database Metadata resolves that location to physical credentials."}),"\n",(0,i.jsx)(n.mermaid,{value:'erDiagram\n    TENANT_METADATA {\n        string TenantID PK\n        string ShardName\n        string DatabaseName\n        string TenantTier\n    }\n    DATABASE_METADATA {\n        string ShardName PK\n        string DatabaseName PK\n        json ConnectionDetails "Writes, Reads, Analytics"\n        string CurrentCapacity\n    }\n    TENANT_METADATA }|..|| DATABASE_METADATA : "resolves to"'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"the-bootup-sequence-initializedb",children:["The Bootup Sequence: ",(0,i.jsx)(n.code,{children:"initializeDB()"})]}),"\n",(0,i.jsx)(n.p,{children:"Efficiency is paramount. We cannot fetch connection details from DynamoDB for every single query. Instead, we cache and initialize heavy resources during application startup."}),"\n",(0,i.jsxs)(n.p,{children:["When the application boots, the ",(0,i.jsx)(n.strong,{children:"Data Access Layer (DAL)"})," performs the following ",(0,i.jsx)(n.code,{children:"initializeDB()"})," routine:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fetch Topology:"})," It scans the ",(0,i.jsx)(n.code,{children:"Database Metadata"})," table to understand the entire available fleet."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pool Creation:"})," For every unique combination of ",(0,i.jsx)(n.code,{children:"Shard"})," + ",(0,i.jsx)(n.code,{children:"Database"})," + ",(0,i.jsx)(n.code,{children:"UseCase"})," (Read/Write), it initializes a connection pool (e.g., HikariCP)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"In-Memory Map:"})," These pools are stored in a concurrent map, keyed by the logical topology identifier."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ensures that all expensive TCP handshakes are done eagerly, and the app is ready to serve traffic immediately upon becoming healthy."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant App as Application (DAL)\n    participant DDB as DynamoDB (DB Metadata)\n    participant DB as Physical Databases\n    \n    Note over App: Application Bootup\n    App->>DDB: Scan Database Metadata Table\n    DDB--\x3e>App: Return List<DbConfig>\n    \n    loop For each DbConfig\n        App->>App: Extract Connection JSON\n        App->>DB: Initialize Connection Pool (HikariCP)\n        DB--\x3e>App: Connection Established\n        App->>App: Map.put(Shard-DB-UseCase, Pool)\n    end\n    \n    Note over App: Ready to serve traffic"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"runtime-request-handling-getconnectiontenantid",children:["Runtime Request Handling: ",(0,i.jsx)(n.code,{children:"getConnection(tenantId)"})]}),"\n",(0,i.jsxs)(n.p,{children:["Once the application is running, the focus shifts to low-latency routing. When a request comes in for ",(0,i.jsx)(n.code,{children:"Tenant-123"}),", the DAL needs to find the correct connection seamlessly."]}),"\n",(0,i.jsxs)(n.p,{children:["The API exposed to the upper layers is simple: ",(0,i.jsx)(n.code,{children:"getConnection(Long tenantId)"}),"."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lookup:"})," The DAL queries the ",(0,i.jsx)(n.code,{children:"Tenant Metadata"})," (often cached locally with a TTL) to find the ",(0,i.jsx)(n.code,{children:"ShardName"})," and ",(0,i.jsx)(n.code,{children:"DatabaseName"})," for the tenant."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resolution:"})," It constructs the lookup key for the in-memory map."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Acquisition:"})," It borrows a connection from the pre-warmed pool and hands it to the request thread."]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TD\n    Request["Incoming Request (Tenant 123)"] --\x3e DAL{Data Access Layer}\n    \n    subgraph Phase1 [Resolution Phase]\n    DAL --\x3e|1. Lookup Tenant| Cache[("Tenant Meta Cache")]\n    Cache --\x3e|Returns| Info["Shard: S1, DB: DB_A"]\n    end\n    \n    subgraph Phase2 [Connection Acquisition]\n    Info --\x3e|2. Construct Key| Key["Key: S1-DB_A-Write"]\n    Key --\x3e|3. Get from Map| Map[Connection Pool Map]\n    Map --\x3e|4. Borrow Connection| Conn[Active Connection]\n    end\n    \n    Conn --\x3e|Returns| DAL\n    DAL --\x3e|Execute Query| DB[("Physical DB Shard 1")]'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"the-strategic-benefits",children:"The Strategic Benefits"}),"\n",(0,i.jsx)(n.p,{children:"Implementing this logic within a library provides two massive architectural advantages that go beyond simple connectivity."}),"\n",(0,i.jsx)(n.h3,{id:"1-logical-representation-of-infrastructure",children:"1. Logical Representation of Infrastructure"}),"\n",(0,i.jsx)(n.p,{children:"The application code never touches a raw JDBC URL."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scenario:"})," You need to rotate database credentials or migrate a database to a new host URL."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action:"})," You simply update the JSON in the ",(0,i.jsx)(n.code,{children:"Database Metadata"})," table and trigger a refresh event in the application."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result:"})," The DAL re-initializes the specific pool. No code deployment is required. The infrastructure is now configuration-driven."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-logical-mapping--zero-downtime-migration",children:"2. Logical Mapping & Zero-Downtime Migration"}),"\n",(0,i.jsx)(n.p,{children:"The mapping between a tenant and a database is fluid, not static."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scenario:"})," ",(0,i.jsx)(n.code,{children:"Tenant-ABC"})," has grown too large for ",(0,i.jsx)(n.code,{children:"Shard-1"})," and needs to be moved to ",(0,i.jsx)(n.code,{children:"Shard-2"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action:"})," After replicating the data to ",(0,i.jsx)(n.code,{children:"Shard-2"}),", you simply update the ",(0,i.jsx)(n.code,{children:"Tenant Metadata"})," table for ",(0,i.jsx)(n.code,{children:"Tenant-ABC"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result:"})," The very next request for ",(0,i.jsx)(n.code,{children:"Tenant-ABC"})," will resolve to ",(0,i.jsx)(n.code,{children:"Shard-2"}),". The application layer requires zero changes to support tenant migration, enabling seamless re-balancing of the fleet."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["Building a shard-aware application is an exercise in ",(0,i.jsx)(n.strong,{children:"separation of concerns"}),". By isolating the ",(0,i.jsx)(n.em,{children:"topology"})," (Tenant Metadata) from the ",(0,i.jsx)(n.em,{children:"infrastructure"})," (Database Metadata) and wrapping it all in a smart Data Access Layer, you gain the flexibility to scale, migrate, and manage your data tier without constantly refactoring your application code."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(6540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);