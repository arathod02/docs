"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[8375],{2420:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var s=r(6601),i=r(4848),t=r(8453);const a={id:"proxysql-deep-dive",title:"Scaling Databases with Proxy Servers",sidebar_label:"Proxy Servers & ProxySQL"},o="Understanding Proxy Servers: A Deep Dive into ProxySQL",l={authorsImageUrls:[]},c=[{value:"Benefits of Using a Proxy Server",id:"benefits-of-using-a-proxy-server",level:2},{value:"Deep Dive: ProxySQL for MySQL",id:"deep-dive-proxysql-for-mysql",level:2},{value:"The Scenario: Elastic Scaling for Burst Traffic",id:"the-scenario-elastic-scaling-for-burst-traffic",level:3},{value:"Using MySQL to Distribute and Divert Traffic",id:"using-mysql-to-distribute-and-divert-traffic",level:2},{value:"a) Configuring Backend Servers",id:"a-configuring-backend-servers",level:3},{value:"b) Significance of LOAD MYSQL SERVERS",id:"b-significance-of-load-mysql-servers",level:3},{value:"c) Significance of SAVE MYSQL SERVERS",id:"c-significance-of-save-mysql-servers",level:3},{value:"d) Adding More Replicas (Scaling Out)",id:"d-adding-more-replicas-scaling-out",level:3},{value:"e) Significance of mysql_query_rules",id:"e-significance-of-mysql_query_rules",level:3},{value:"f) Routing Based on Query Type (Read/Write Split)",id:"f-routing-based-on-query-type-readwrite-split",level:3},{value:"g) Routing Based on Schema (Analytics vs. Transactions)",id:"g-routing-based-on-schema-analytics-vs-transactions",level:3},{value:"h) Comment/Hint Based Routing",id:"h-commenthint-based-routing",level:3},{value:"Deployment of ProxySQL",id:"deployment-of-proxysql",level:2},{value:"1. Fleet of ProxySQL Fronted by a Load Balancer",id:"1-fleet-of-proxysql-fronted-by-a-load-balancer",level:3},{value:"2. ProxySQL Cluster Mode (Native Clustering)",id:"2-proxysql-cluster-mode-native-clustering",level:3},{value:"Elastic Topology Visualization",id:"elastic-topology-visualization",level:2},{value:"AWS Aurora Alternative: Custom Endpoints",id:"aws-aurora-alternative-custom-endpoints",level:2},{value:"Visualizing Aurora Custom Endpoints",id:"visualizing-aurora-custom-endpoints",level:3},{value:"Conclusion",id:"conclusion",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In the complex landscape of distributed systems, direct communication between clients and backend resources is often inefficient or insecure. Enter the ",(0,i.jsx)(n.strong,{children:"Proxy Server"}),"\u2014an intermediary that sits between the end-user clients and the resources they intend to browse or access."]}),"\n",(0,i.jsx)(n.p,{children:"In the context of database architecture, a database proxy abstracts the underlying database topology from the application layer. Instead of applications connecting directly to a specific database instance (like a primary or a replica), they connect to the proxy, which then intelligently routes the query to the appropriate destination."}),"\n",(0,i.jsxs)(n.p,{children:["Popular examples in the relational database world include ",(0,i.jsx)(n.strong,{children:"PgBouncer"})," for PostgreSQL, which excels at connection pooling, and ",(0,i.jsx)(n.strong,{children:"ProxySQL"})," or ",(0,i.jsx)(n.strong,{children:"MaxScale"})," for MySQL, which provide advanced features like query routing, caching, and failover management."]}),"\n",(0,i.jsx)(n.h2,{id:"benefits-of-using-a-proxy-server",children:"Benefits of Using a Proxy Server"}),"\n",(0,i.jsx)(n.p,{children:"Implementing a proxy server in your database architecture offers several robust advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Connection Pooling and Multiplexing"}),"\nOpening and closing database connections is an expensive operation. Proxies maintain a pool of open connections to the backend databases and reuse them for multiple client requests (multiplexing). This drastically reduces the connection overhead on the database server, allowing it to dedicate more resources to executing queries rather than managing network handshakes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Load Balancing and Read/Write Splitting"}),"\nProxies can distribute incoming traffic across multiple database nodes. By identifying the type of query (e.g., specific ",(0,i.jsx)(n.code,{children:"SELECT"})," statements versus ",(0,i.jsx)(n.code,{children:"INSERT"}),"/",(0,i.jsx)(n.code,{children:"UPDATE"}),"s), the proxy can automatically route write operations to the primary node and read operations to read replicas. This ensures optimal resource utilization and prevents a single node from becoming a bottleneck."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"High Availability and Failover"}),"\nA proxy creates an abstraction layer that insulates the application from database failures. If a database node goes down, the proxy detects the failure and immediately stops sending traffic to that node, rerouting it to healthy instances. This failover happens transparently to the application, which continues to communicate with the proxy without realizing the backend topology has changed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Query Caching"}),"\nSome advanced proxies can cache the results of frequently executed queries in their own memory. If a client requests data that is already cached, the proxy serves the result instantly without ever hitting the backend database. This significantly reduces latency for the application and lowers the load on the database server."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"deep-dive-proxysql-for-mysql",children:"Deep Dive: ProxySQL for MySQL"}),"\n",(0,i.jsx)(n.p,{children:"ProxySQL is a high-performance, open-source proxy for MySQL (and forks like Percona Server and MariaDB). It is uniquely designed to solve the challenges of high-traffic, highly available database clusters. Unlike simple connection poolers, ProxySQL understands the SQL protocol, allowing it to inspect queries and make intelligent routing decisions based on the actual SQL content, user, or schema."}),"\n",(0,i.jsx)(n.h3,{id:"the-scenario-elastic-scaling-for-burst-traffic",children:"The Scenario: Elastic Scaling for Burst Traffic"}),"\n",(0,i.jsx)(n.p,{children:"Let's weave our exploration around a specific, common business scenario:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Use Case:"}),' Imagine an e-commerce platform that experiences a massive surge in traffic only during "Flash Sales" (e.g., 6 PM to 8 PM). During these hours, read traffic spikes by 10x.']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Strategy:"})," To handle this cost-effectively, we want an ",(0,i.jsx)(n.strong,{children:"elastic database topology"}),". We will spin up additional Read Replicas specifically for the flash sale window and tear them down afterward."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Challenge:"})," We need to add and remove these database nodes dynamically ",(0,i.jsx)(n.em,{children:"without"})," changing application code, ",(0,i.jsx)(n.em,{children:"without"})," redeploying the app, and ",(0,i.jsx)(n.em,{children:"without"})," any downtime."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"using-mysql-to-distribute-and-divert-traffic",children:"Using MySQL to Distribute and Divert Traffic"}),"\n",(0,i.jsxs)(n.p,{children:["ProxySQL manages backend servers using ",(0,i.jsx)(n.strong,{children:"Hostgroups"}),". A hostgroup is simply a logical grouping of database servers (e.g., Hostgroup 10 for Writers, Hostgroup 20 for Readers)."]}),"\n",(0,i.jsx)(n.p,{children:"Let's walk through the configuration steps to achieve our elastic routing."}),"\n",(0,i.jsx)(n.h3,{id:"a-configuring-backend-servers",children:"a) Configuring Backend Servers"}),"\n",(0,i.jsxs)(n.p,{children:["First, we define our backend servers in the ",(0,i.jsx)(n.code,{children:"mysql_servers"})," table."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hostgroup 10:"})," The Primary Writer (High consistency)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hostgroup 20:"})," The Permanent Readers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hostgroup 30:"}),' The "Flash Sale" Elastic Readers (only active during surges).']}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Connect to ProxySQL Admin interface (usually port 6032)\n-- Insert the Writer (Primary)\nINSERT INTO mysql_servers (hostgroup_id, hostname, port) \nVALUES (10, 'db-primary', 3306);\n\n-- Insert the Permanent Reader\nINSERT INTO mysql_servers (hostgroup_id, hostname, port) \nVALUES (20, 'db-reader-permanent', 3306);\n\n-- Insert the Elastic Readers (initially can be offline or added dynamically)\nINSERT INTO mysql_servers (hostgroup_id, hostname, port) \nVALUES (30, 'db-reader-elastic-1', 3306);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"b-significance-of-load-mysql-servers",children:"b) Significance of LOAD MYSQL SERVERS"}),"\n",(0,i.jsxs)(n.p,{children:["When you run the ",(0,i.jsx)(n.code,{children:"INSERT"})," commands above, you are modifying the configuration in ",(0,i.jsx)(n.strong,{children:"Memory"})," (specifically, the ",(0,i.jsx)(n.code,{children:"main"})," database in memory). These changes are not yet effective for live traffic."]}),"\n",(0,i.jsx)(n.p,{children:"To apply these changes to the runtime engine (the part of ProxySQL actually handling traffic), you must run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"LOAD MYSQL SERVERS TO RUNTIME;\n"})}),"\n",(0,i.jsx)(n.p,{children:'This command acts as a "commit" to the running process. It tells ProxySQL to start using the new server list immediately without restarting the service.'}),"\n",(0,i.jsx)(n.h3,{id:"c-significance-of-save-mysql-servers",children:"c) Significance of SAVE MYSQL SERVERS"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"LOAD"})," pushes changes to runtime, it does not persist them to disk. If ProxySQL restarts, all changes in memory are lost. To ensure your configuration survives a reboot, you must save them to the internal SQLite database file on disk:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SAVE MYSQL SERVERS TO DISK;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"d-adding-more-replicas-scaling-out",children:"d) Adding More Replicas (Scaling Out)"}),"\n",(0,i.jsx)(n.p,{children:'When the "Flash Sale" begins, your orchestration tool (like Terraform or Kubernetes) provisions new DB replicas. To register them with ProxySQL:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Adding new elastic nodes for the surge\nINSERT INTO mysql_servers (hostgroup_id, hostname, port) \nVALUES (30, 'db-reader-elastic-2', 3306);\n\nINSERT INTO mysql_servers (hostgroup_id, hostname, port) \nVALUES (30, 'db-reader-elastic-3', 3306);\n\n-- Apply changes instantly\nLOAD MYSQL SERVERS TO RUNTIME;\nSAVE MYSQL SERVERS TO DISK;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"The application knows nothing about these new IPs; it just continues talking to ProxySQL."})}),"\n",(0,i.jsx)(n.h3,{id:"e-significance-of-mysql_query_rules",children:"e) Significance of mysql_query_rules"}),"\n",(0,i.jsxs)(n.p,{children:["The real magic happens in the ",(0,i.jsx)(n.code,{children:"mysql_query_rules"})," table. This acts as a firewall and router combined. You define rules that match specific criteria (regex on the query, username, schema name, etc.) and assign an action, such as assigning a ",(0,i.jsx)(n.code,{children:"destination_hostgroup"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["ProxySQL evaluates rules in order of their ",(0,i.jsx)(n.code,{children:"rule_id"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"f-routing-based-on-query-type-readwrite-split",children:"f) Routing Based on Query Type (Read/Write Split)"}),"\n",(0,i.jsxs)(n.p,{children:["A classic rule is to send all ",(0,i.jsx)(n.code,{children:"SELECT"})," queries to the reader groups (Hostgroup 20 and 30) and everything else to the writer (Hostgroup 10)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Rule: Direct all SELECT statements to Hostgroup 20 (Readers)\nINSERT INTO mysql_query_rules (rule_id, active, match_digest, destination_hostgroup, apply)\nVALUES (\n    100,                 -- rule_id\n    1,                   -- active\n    '^SELECT.*',         -- match_digest (Regex for queries starting with SELECT)\n    20,                  -- destination_hostgroup (Permanent Readers)\n    1                    -- apply (Stop processing further rules if this matches)\n);\n\nLOAD MYSQL QUERY RULES TO RUNTIME;\nSAVE MYSQL QUERY RULES TO DISK;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:'Note: In production, you might set up a "Replication Lag" check so ProxySQL doesn\'t send queries to readers that are too far behind the writer.'})}),"\n",(0,i.jsx)(n.h3,{id:"g-routing-based-on-schema-analytics-vs-transactions",children:"g) Routing Based on Schema (Analytics vs. Transactions)"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose you have a specific schema ",(0,i.jsx)(n.code,{children:"analytics_db"})," that runs heavy aggregation queries. You don't want these blocking your transactional users. You can route traffic hitting this specific schema to the elastic hostgroup (Hostgroup 30)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Rule: Direct traffic for schema 'analytics_db' to Hostgroup 30\nINSERT INTO mysql_query_rules (rule_id, active, schemaname, destination_hostgroup, apply)\nVALUES (\n    50,                  -- Lower ID = Higher Priority than the generic SELECT rule\n    1, \n    'analytics_db',      -- Exact match on schema name\n    30,                  -- Elastic/Analytics Readers\n    1\n);\n\nLOAD MYSQL QUERY RULES TO RUNTIME;\nSAVE MYSQL QUERY RULES TO DISK;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"h-commenthint-based-routing",children:"h) Comment/Hint Based Routing"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes regex isn't enough. You might have a critical ",(0,i.jsx)(n.code,{children:"SELECT"})," statement (e.g., checking inventory before checkout) that ",(0,i.jsx)(n.em,{children:"must"})," go to the Writer (Hostgroup 10) to ensure strong consistency, bypassing the replica entirely."]}),"\n",(0,i.jsx)(n.p,{children:"Developers can inject a SQL comment (hint) into the query, and ProxySQL can route based on that comment."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example Query from Application:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"/* forceful_write */ SELECT quantity FROM products WHERE id = 101;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"ProxySQL Rule:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Rule: If query contains \"forceful_write\", send to Writer (HG 10)\nINSERT INTO mysql_query_rules (rule_id, active, match_digest, destination_hostgroup, apply)\nVALUES (\n    10,                  -- Highest Priority\n    1,\n    'forceful_write',    -- Regex matching the comment\n    10,                  -- Writer Hostgroup\n    1\n);\n\nLOAD MYSQL QUERY RULES TO RUNTIME;\nSAVE MYSQL QUERY RULES TO DISK;\n"})}),"\n",(0,i.jsx)(n.p,{children:"This gives developers granular control over routing without hardcoding IP addresses in the application."}),"\n",(0,i.jsx)(n.h2,{id:"deployment-of-proxysql",children:"Deployment of ProxySQL"}),"\n",(0,i.jsx)(n.h3,{id:"1-fleet-of-proxysql-fronted-by-a-load-balancer",children:"1. Fleet of ProxySQL Fronted by a Load Balancer"}),"\n",(0,i.jsx)(n.p,{children:"In this topology, you run multiple independent ProxySQL instances behind a classic Load Balancer (like AWS NLB or HAProxy)."}),"\n",(0,i.jsx)(n.mermaid,{value:"flowchart TD\n    Client[Application] --\x3e LB(Load Balancer)\n    LB --\x3e Proxy1[ProxySQL A]\n    LB --\x3e Proxy2[ProxySQL B]\n    LB --\x3e Proxy3[ProxySQL C]\n    \n    Proxy1 --\x3e DB[(Databases)]\n    Proxy2 --\x3e DB\n    Proxy3 --\x3e DB"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simple to understand:"})," Each ProxySQL node is independent."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Availability:"})," If one ProxySQL node dies, the Load Balancer removes it."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration Drift:"})," If you add a new query rule to ",(0,i.jsx)(n.code,{children:"ProxySQL A"}),", you must manually apply the exact same SQL commands to ",(0,i.jsx)(n.code,{children:"ProxySQL B"})," and ",(0,i.jsx)(n.code,{children:"C"}),". Automation tools (Ansible/Chef) are required to keep them in sync."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Split Brain Risks:"})," If configurations diverge, users might get different results depending on which proxy the Load Balancer hits."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-proxysql-cluster-mode-native-clustering",children:"2. ProxySQL Cluster Mode (Native Clustering)"}),"\n",(0,i.jsx)(n.p,{children:"ProxySQL supports native clustering. You configure the instances to form a cluster, and they automatically synchronize their configuration."}),"\n",(0,i.jsx)(n.mermaid,{value:"flowchart TD\n    Client[Application] --\x3e LB(Load Balancer)\n    \n    subgraph ProxySQL_Cluster [ProxySQL Native Cluster]\n        Proxy1[ProxySQL Leader]\n        Proxy2[ProxySQL Follower]\n        Proxy3[ProxySQL Follower]\n        \n        Proxy1 <--\x3e|Sync Config| Proxy2\n        Proxy2 <--\x3e|Sync Config| Proxy3\n        Proxy3 <--\x3e|Sync Config| Proxy1\n    end\n    \n    ProxySQL_Cluster --\x3e DB[(Databases)]"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Auto-Synchronization:"})," You only need to run the ",(0,i.jsx)(n.code,{children:"INSERT"})," and ",(0,i.jsx)(n.code,{children:"LOAD"})," commands on ",(0,i.jsx)(n.em,{children:"one"})," node. The changes are automatically propagated to all other nodes in the cluster."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Management Ease:"})," Drastically reduces the operational overhead of managing a large fleet."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complexity:"})," Setting up the internal cluster network requires careful configuration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Network Overhead:"})," There is a small amount of traffic between proxies for synchronization."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"elastic-topology-visualization",children:"Elastic Topology Visualization"}),"\n",(0,i.jsx)(n.p,{children:"Here is how our Elastic/Flash Sale setup looks. The application connects to ProxySQL, which handles the dynamic routing to the elastic fleet."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TD\n    subgraph APP_LAYER [Application Layer]\n        App1[App Instance 1]\n        App2[App Instance 2]\n    end\n\n    subgraph PROXY_LAYER [ProxySQL Layer]\n        P1[ProxySQL]\n    end\n\n    subgraph DB_LAYER [Database Layer]\n        Writer[(Primary DB \\n HG: 10)]\n        ReaderPerm[(Reader Permanent \\n HG: 20)]\n        ReaderElastic1[(Reader Elastic 1 \\n HG: 30 \\n *Flash Sale*)]\n        ReaderElastic2[(Reader Elastic 2 \\n HG: 30 \\n *Flash Sale*)]\n    end\n\n    App1 --\x3e P1\n    App2 --\x3e P1\n\n    P1 -- "INSERT / UPDATE" --\x3e Writer\n    P1 -- "SELECT (Standard)" --\x3e ReaderPerm\n    P1 -- "SELECT (Analytics/High Load)" --\x3e ReaderElastic1\n    P1 -- "SELECT (Analytics/High Load)" --\x3e ReaderElastic2'}),"\n",(0,i.jsx)(n.h2,{id:"aws-aurora-alternative-custom-endpoints",children:"AWS Aurora Alternative: Custom Endpoints"}),"\n",(0,i.jsxs)(n.p,{children:["If you are hosted specifically on AWS Aurora, you might not always need an external layer like ProxySQL for basic traffic segregation. Aurora offers a native feature called ",(0,i.jsx)(n.strong,{children:"Custom Endpoints"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In the AWS Aurora ecosystem, ",(0,i.jsx)(n.strong,{children:"Custom Endpoints"})," offer a native alternative to external proxies for routing traffic to specific groups of database instances. Unlike the standard Cluster Reader Endpoint which cycles through ",(0,i.jsx)(n.em,{children:"all"})," available replicas, a Custom Endpoint allows you to arbitrarily group specific instances\u2014such as high-performance nodes\u2014into a distinct VIP. When an application connects to this custom DNS name, Aurora performs DNS-based load balancing to distribute connections across only the pre-selected instances in that group. This feature is ideal for isolating workloads; for example, you can direct heavy analytical reports to a specific set of larger instances while keeping fast transactional reads on smaller instances for the web application. Because it operates at the DNS level, it provides instance-level isolation but lacks the granular query-level routing rules (regex parsing) found in tools like ProxySQL. It simplifies infrastructure management by removing the need for an intermediate proxy layer when simple instance grouping satisfies the routing requirements."]}),"\n",(0,i.jsx)(n.h3,{id:"visualizing-aurora-custom-endpoints",children:"Visualizing Aurora Custom Endpoints"}),"\n",(0,i.jsx)(n.p,{children:"The following diagram illustrates how a Custom Endpoint acts as a specific entry point, load balancing traffic across a dedicated subset of readers, separate from the general traffic."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph Clients\n        App["Web Application"]\n        Analytics["Analytics Service"]\n    end\n\n    subgraph Aurora_Cluster ["AWS Aurora Cluster"]\n        \n        subgraph Endpoints\n            DefaultEP("Default Reader Endpoint")\n            CustomEP("Custom Endpoint *Analytics*")\n        end\n        \n        subgraph Reader_Nodes ["Read Replicas"]\n            R1["Reader 1 (General)"]\n            R2["Reader 2 (General)"]\n            R3["Reader 3 (Analytics Specific)"]\n            R4["Reader 4 (Analytics Specific)"]\n        end\n\n        %% Routing Logic\n        DefaultEP -.->|Load Balance| R1\n        DefaultEP -.->|Load Balance| R2\n        \n        CustomEP -.->|Load Balance| R3\n        CustomEP -.->|Load Balance| R4\n    end\n\n    App --\x3e|Connects to| DefaultEP\n    Analytics --\x3e|Connects to| CustomEP'}),"\n",(0,i.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:['By leveraging ProxySQL, we effectively decoupled our application from the database infrastructure. We achieved the ability to "burst" our read capacity by adding elastic nodes (Hostgroup 30) and routing heavy traffic to them via ',(0,i.jsx)(n.code,{children:"mysql_query_rules"}),". All of this happened transparently to the application, ensuring high availability and cost efficiency during peak business hours."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6601:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/proxy-server","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/proxy-server.md","source":"@site/blog/proxy-server.md","title":"Scaling Databases with Proxy Servers","description":"In the complex landscape of distributed systems, direct communication between clients and backend resources is often inefficient or insecure. Enter the Proxy Server\u2014an intermediary that sits between the end-user clients and the resources they intend to browse or access.","date":"2025-12-25T11:38:10.000Z","tags":[],"readingTime":10.18,"hasTruncateMarker":false,"authors":[],"frontMatter":{"id":"proxysql-deep-dive","title":"Scaling Databases with Proxy Servers","sidebar_label":"Proxy Servers & ProxySQL"},"unlisted":false,"nextItem":{"title":"Real-Time Communication with Server-Sent Events (SSE)","permalink":"/docs/blog/server-sent-events-explained"}}')},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);