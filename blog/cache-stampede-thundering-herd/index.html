<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">The Thundering Herd - Understanding and Solving the Cache Stampede | Ashish Rathod</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://arathod02.github.io/docs/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://arathod02.github.io/docs/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="The Thundering Herd - Understanding and Solving the Cache Stampede | Ashish Rathod"><meta data-rh="true" name="description" content="In the world of high-scale distributed systems, caching is our best friend. It’s the primary defense layer that protects our fragile databases from the onslaught of user traffic, ensuring low latency and high throughput."><meta data-rh="true" property="og:description" content="In the world of high-scale distributed systems, caching is our best friend. It’s the primary defense layer that protects our fragile databases from the onslaught of user traffic, ensuring low latency and high throughput."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2025-12-11T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://www.linkedin.com/in/ashish-rathod02/"><link data-rh="true" rel="icon" href="/docs/img/favicon.jpg"><link data-rh="true" rel="canonical" href="https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd"><link data-rh="true" rel="alternate" href="https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd" hreflang="en"><link data-rh="true" rel="alternate" href="https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd","mainEntityOfPage":"https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd","url":"https://arathod02.github.io/docs/blog/cache-stampede-thundering-herd","headline":"The Thundering Herd - Understanding and Solving the Cache Stampede","name":"The Thundering Herd - Understanding and Solving the Cache Stampede","description":"In the world of high-scale distributed systems, caching is our best friend. It’s the primary defense layer that protects our fragile databases from the onslaught of user traffic, ensuring low latency and high throughput.","datePublished":"2025-12-11T00:00:00.000Z","author":{"@type":"Person","name":"Ashish Rathod","description":"Ex-Intuit Staff Engineer","url":"https://www.linkedin.com/in/ashish-rathod02/","image":"https://github.com/arathod02.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://arathod02.github.io/docs/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/docs/blog/rss.xml" title="Ashish Rathod RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs/blog/atom.xml" title="Ashish Rathod Atom Feed"><link rel="stylesheet" href="/docs/assets/css/styles.aade1aad.css">
<script src="/docs/assets/js/runtime~main.2307e74a.js" defer="defer"></script>
<script src="/docs/assets/js/main.4a3975e2.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/docs/img/favicon.jpg"><link rel="preload" as="image" href="https://github.com/arathod02.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs/"><div class="navbar__logo"><img src="/docs/img/favicon.jpg" alt="Ashish Rathod Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/docs/img/favicon.jpg" alt="Ashish Rathod Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Ashish Rathod</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/load-balancer-design">Designing L7 Load Balancer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/concurrent-replace">Avoid &quot;REPLACE INTO&quot;</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/slack-design">Slack Architecture</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/distributed-key-value-store">Distributed Key-Value Store</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/db-pessimistic-optimistic-locking">Deep Dive into Database Pessimistic &amp; Optimistic Locking</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/proxy-server">Database Proxy Servers</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/server-sent-events-explained">Real-Time Communication with Server-Sent Events (SSE)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/application-level-sharding-design">Implementing Shard Aware Application</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/scaling-distributed-systems">Scaling Distributed Systems (Focus on Databases)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/avoid-hard-deletes">The Pains of Hard Delete</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/docs/blog/cache-stampede-thundering-herd">The Thundering Herd - Understanding and Solving the Cache Stampede</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/transformer-architecture">The Transformer Architecture</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/docs/blog/offline-online-indicator">Presence Service</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">The Thundering Herd - Understanding and Solving the Cache Stampede</h1><div class="container_mt6G margin-vert--md"><time datetime="2025-12-11T00:00:00.000Z">December 11, 2025</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a class="avatar__photo-link" href="/docs/blog/authors/ashish"><img class="avatar__photo authorImage_XqGP" src="https://github.com/arathod02.png" alt="Ashish Rathod"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="/docs/blog/authors/ashish"><span class="authorName_yefp" translate="no">Ashish Rathod</span></a></div><small class="authorTitle_nd0D" title="Ex-Intuit Staff Engineer">Ex-Intuit Staff Engineer</small><div class="authorSocials_rSDt"><a href="https://www.linkedin.com/in/ashish-rathod02/" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" preserveAspectRatio="xMidYMid" viewBox="0 0 256 256" style="--dark:#0a66c2;--light:#ffffffe6" class="authorSocialIcon_XYv3 linkedinSvg_FCgI"><path d="M218.123 218.127h-37.931v-59.403c0-14.165-.253-32.4-19.728-32.4-19.756 0-22.779 15.434-22.779 31.369v60.43h-37.93V95.967h36.413v16.694h.51a39.907 39.907 0 0 1 35.928-19.733c38.445 0 45.533 25.288 45.533 58.186l-.016 67.013ZM56.955 79.27c-12.157.002-22.014-9.852-22.016-22.009-.002-12.157 9.851-22.014 22.008-22.016 12.157-.003 22.014 9.851 22.016 22.008A22.013 22.013 0 0 1 56.955 79.27m18.966 138.858H37.95V95.967h37.97v122.16ZM237.033.018H18.89C8.58-.098.125 8.161-.001 18.471v219.053c.122 10.315 8.576 18.582 18.89 18.474h218.144c10.336.128 18.823-8.139 18.966-18.474V18.454c-.147-10.33-8.635-18.588-18.966-18.453"></path></svg></a><a href="https://github.com/arathod02" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 256 250" preserveAspectRatio="xMidYMid" style="--dark:#000;--light:#fff" class="authorSocialIcon_XYv3 githubSvg_Uu4N"><path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z"></path></svg></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>In the world of high-scale distributed systems, caching is our best friend. It’s the primary defense layer that protects our fragile databases from the onslaught of user traffic, ensuring low latency and high throughput.</p>
<p>But what happens when that defense layer momentarily fails exactly when you need it most?</p>
<p>Welcome to the <strong>Cache Stampede</strong> problem—also known as the &quot;Thundering Herd.&quot; It&#x27;s a scenario where the very mechanism designed to speed up your system ends up bringing it to its knees.</p>
<p>Let&#x27;s dive into what it is, why it happens, and the practical techniques used by major systems (like CDNs) to solve it.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-typical-architecture"><strong>The Typical Architecture</strong><a href="#the-typical-architecture" class="hash-link" aria-label="Direct link to the-typical-architecture" title="Direct link to the-typical-architecture" translate="no">​</a></h2>
<p>Before things go wrong, let&#x27;s look at how things go right.</p>
<p>Consider a standard three-tier web architecture. We have API servers fronted by a load balancer. Sitting between these API servers and the &quot;source of truth&quot; (the Database) is a caching layer (like Redis or Memcached).</p>
<p>The goal of the cache is simple: serve data fast and reduce load on the database.</p>
<p>Here is a high-level view of this architecture:</p>
<!-- -->
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-happy-path-flow"><strong>The &quot;Happy Path&quot; Flow</strong><a href="#the-happy-path-flow" class="hash-link" aria-label="Direct link to the-happy-path-flow" title="Direct link to the-happy-path-flow" translate="no">​</a></h3>
<p>Under normal operation, the flow for retrieving data is a standard &quot;Read-Through&quot; cache pattern:</p>
<ol>
<li class="">The API Server receives a request for a specific key.</li>
<li class="">It first checks the cache.</li>
<li class=""><strong>Cache Hit:</strong> If the data is there, return it immediately. (Fast!)</li>
<li class=""><strong>Cache Miss:</strong> If the data is <em>not</em> there:<!-- -->
<ul>
<li class="">Query the Database (Slow).</li>
<li class="">Populate the cache with the result for future requests.</li>
<li class="">Return the result to the client.</li>
</ul>
</li>
</ol>
<p>Here is what this typically looks like in simple Java pseudo-code:</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SimpleDataService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Cache cache;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Database db;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getData(String key) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1. Try fetching from cache  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String cachedValue = cache.get(key);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cachedValue != null) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return cachedValue;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. Cache miss - fetch from source of truth  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String dbValue = db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3. Backfill cache for next time  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Note: Often done with a Time-To-Live (TTL) to ensure freshness  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache.put(key, dbValue, Duration.ofMinutes(5)); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dbValue;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>This works perfectly fine for normal traffic loads. The database only sees an occasional read when cache items expire.</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-problem-the-stampede-begins"><strong>The Problem: The Stampede Begins</strong><a href="#the-problem-the-stampede-begins" class="hash-link" aria-label="Direct link to the-problem-the-stampede-begins" title="Direct link to the-problem-the-stampede-begins" translate="no">​</a></h2>
<p>Now, imagine a scenario where a piece of content goes viral.</p>
<p>Suddenly, you have thousands of concurrent requests hitting your load balancer for the exact same resource key (e.g., product_details_123).</p>
<p>If the cache entry for product_details_123 has just expired, or perhaps was evicted due to memory pressure, you have a problem.</p>
<p>In that brief window of time—perhaps just a few hundred milliseconds before the first request can refill the cache—<strong>every single concurrent request will result in a Cache Miss.</strong></p>
<p>If 5,000 requests arrive simultaneously for that missing key, all 5,000 requests will bypass the cache and bombard your database at the exact same moment.</p>
<p>Your database, which was happily serving a few dozen requests per second, suddenly receives thousands. CPU spikes, connection pools become exhausted, queries time out, and the database might even crash. This is the Cache Stampede. It defeats the entire purpose of having a cache.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-solution-request-hedging-debouncing"><strong>The Solution: Request Hedging (Debouncing)</strong><a href="#the-solution-request-hedging-debouncing" class="hash-link" aria-label="Direct link to the-solution-request-hedging-debouncing" title="Direct link to the-solution-request-hedging-debouncing" translate="no">​</a></h2>
<p>To handle this, we need to ensure that when a &quot;hot&quot; cache key is missing, we don&#x27;t let the entire herd stampede to the database. We need to designate a leader.</p>
<p>We leverage a technique known as <strong>Request Hedging</strong> or <strong>Debouncing</strong>.</p>
<p>The concept is straightforward: Out of the thousands of concurrent requests for the missing key, we allow <strong>only one</strong> to proceed to the database. All other requests for that same key must <strong>wait</strong> until that first request completes the job and refills the cache. Once the cache is refilled, the waiting requests can read the data from the cache and proceed.</p>
<p>The idea is simple, but as always, the devil is in the implementation details. How do we make requests wait efficiently and cleanly in a highly concurrent environment? Let&#x27;s look at two approaches in Java.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="approach-1-the-busy-wait-spinlock"><strong>Approach 1: The Busy Wait (Spinlock)</strong><a href="#approach-1-the-busy-wait-spinlock" class="hash-link" aria-label="Direct link to approach-1-the-busy-wait-spinlock" title="Direct link to approach-1-the-busy-wait-spinlock" translate="no">​</a></h3>
<p>In this technique, if a thread finds a cache miss, it enters a loop where it continuously checks the cache again after sleeping for a tiny duration. It &quot;spins&quot; until data appears.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="pseudo-code-busy-wait"><strong>Pseudo-code (Busy Wait)</strong><a href="#pseudo-code-busy-wait" class="hash-link" aria-label="Direct link to pseudo-code-busy-wait" title="Direct link to pseudo-code-busy-wait" translate="no">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BusyWaitDataService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Cache cache;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Database db;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getData(String key) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String value = cache.get(key);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If cache hit, return immediately  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value != null) return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Determine if I am the &quot;leader&quot; responsible for fetching.  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Use an atomic operation like &#x27;setIfAbsent&#x27; (NX) in Redis.  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set a short TTL on this lock to prevent deadlocks if the service crashes.  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean acquiredLock = cache.setIfAbsent(&quot;lock::&quot; + key, &quot;locked&quot;, Duration.ofSeconds(5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (acquiredLock) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // I am the leader. Fetch from DB.  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value = db.query(key);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cache.put(key, value, Duration.ofMinutes(5));  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Release lock so others know fetching is done  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cache.delete(&quot;lock::&quot; + key);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // I am a follower. Spin and wait.  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (value == null) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Sleep briefly to avoid hammering CPU  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(50);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) { Thread.currentThread().interrupt(); }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Check cache again  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value = cache.get(key);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Optional: Check if lock still exists, if not, break and retry fetch  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-downside"><strong>The Downside</strong><a href="#the-downside" class="hash-link" aria-label="Direct link to the-downside" title="Direct link to the-downside" translate="no">​</a></h4>
<p>As the name suggests, this approach makes the CPU &quot;busy.&quot; Even though the threads are sleeping, the constant context switching and polling consumes precious CPU cycles. In high-load scenarios, this wasted CPU can become substantial. It works, but it&#x27;s not elegant.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="approach-2-the-waitnotify-mechanism-jvm-locksfutures"><strong>Approach 2: The Wait/Notify Mechanism (JVM Locks/Futures)</strong><a href="#approach-2-the-waitnotify-mechanism-jvm-locksfutures" class="hash-link" aria-label="Direct link to approach-2-the-waitnotify-mechanism-jvm-locksfutures" title="Direct link to approach-2-the-waitnotify-mechanism-jvm-locksfutures" translate="no">​</a></h3>
<p>A far more efficient approach is to use native concurrency constructs. Instead of polling, threads should block and go to sleep until they are explicitly notified that the data is ready.</p>
<p>In modern Java, a CompletableFuture combined with a ConcurrentHashMap is a robust way to implement this &quot;promise&quot; pattern without getting tangled in low-level monitor locks (synchronized/wait/notify).</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="pseudo-code-waitnotify-with-futures"><strong>Pseudo-code (Wait/Notify with Futures)</strong><a href="#pseudo-code-waitnotify-with-futures" class="hash-link" aria-label="Direct link to pseudo-code-waitnotify-with-futures" title="Direct link to pseudo-code-waitnotify-with-futures" translate="no">​</a></h4>
<p>We maintain a local map of &quot;pending database operations.&quot; If a request comes in and an operation is already pending for that key, we hook into that existing operation&#x27;s future result.</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class BlogService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // &quot;use threadsafe implementation here&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // sem_map: Tracks which keys are currently being fetched</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private final ConcurrentHashMap&lt;String, CountDownLatch&gt; semMap = new ConcurrentHashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // res_map: Temporary storage for followers to grab the result immediately</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // Note: In a real impl, this might need a TTL (e.g., &quot;1 min&quot; per your note) or explicit cleanup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private final ConcurrentHashMap&lt;String, String&gt; resMap = new ConcurrentHashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public String getBlog(String k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 1. Check main cache first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      String v = cache.get(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (v != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 2. Check Semaphore Map (Thread-safe check)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // We attempt to create a &quot;lock&quot; (Latch) for this key.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      CountDownLatch myLatch = new CountDownLatch(1); // Starts &quot;blocked&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // &quot;s = sem_map.get(k)&quot; equivalent using atomic putIfAbsent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // If returns value: someone else is already fetching (we are follower)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // If returns null: we successfully inserted (we are leader)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      CountDownLatch existingLatch = semMap.putIfAbsent(k, myLatch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (existingLatch != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // --- FOLLOWER PATH (&quot;if s: s.wait()&quot;) ---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Wait for the leader to signal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            existingLatch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return resMap.get(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // --- LEADER PATH (&quot;else&quot;) ---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            v = db.query(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // &quot;cache.put(k, v)&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.put(k, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // &quot;res_map[k] = v&quot; (Temporary map)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            resMap.put(k, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Open the gate for followers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            myLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //Cleanup lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            semMap.remove(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Optional: You might schedule resMap cleanup here or rely on TTL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-benefit"><strong>The Benefit</strong><a href="#the-benefit" class="hash-link" aria-label="Direct link to the-benefit" title="Direct link to the-benefit" translate="no">​</a></h4>
<p>This approach is highly efficient. Waiting threads are parked by the OS and consume virtually no CPU until the leader thread completes the future. It handles concurrency cleanly within a single JVM.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-pragmatic-scope-jvm-vs-distributed-locks"><strong>The Pragmatic Scope: JVM vs. Distributed Locks</strong><a href="#the-pragmatic-scope-jvm-vs-distributed-locks" class="hash-link" aria-label="Direct link to the-pragmatic-scope-jvm-vs-distributed-locks" title="Direct link to the-pragmatic-scope-jvm-vs-distributed-locks" translate="no">​</a></h3>
<p>A sharp observer might notice a slight flaw in Approach 2. The guardrails of approach 2 exist within the memory of a <em>single</em> API server JVM.</p>
<p>If you have a fleet of 20 API servers behind your load balancer, and a stampede occurs, <em>one</em> request on <em>each</em> of the 20 servers will proceed to the database.</p>
<p>Instead of 5,000 database hits, you will have 20 hits.</p>
<p>Is this perfect? No. To reduce it to exactly one global hit, you would need a <strong>Distributed Lock</strong> system (using Redis, Zookeeper, or etcd) to coordinate locking across all 20 servers.</p>
<p>However, distributed locks introduce significant complexity, latency, and a new point of failure.</p>
<p><strong>In practice, the JVM-level solution is often the pragmatic choice.</strong> Reducing 5,000 simultaneous requests down to 20 is usually sufficient to save the database. It&#x27;s a massive improvement for relatively low implementation complexity.</p>
<p>It&#x27;s worth noting that large-scale Content Delivery Networks (CDNs) like Cloudflare, Akamai, and Fastly use exactly this hedging technique at their edge locations to protect customer origin servers from getting overwhelmed when content goes viral.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/thundering-herd-problem.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/blog/avoid-hard-deletes"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">A Deep Dive into Database Storage Engines and Soft Deletion Strategies.</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/blog/transformer-architecture"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">The Transformer Architecture</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-typical-architecture" class="table-of-contents__link toc-highlight"><strong>The Typical Architecture</strong></a><ul><li><a href="#the-happy-path-flow" class="table-of-contents__link toc-highlight"><strong>The &quot;Happy Path&quot; Flow</strong></a></li></ul></li><li><a href="#the-problem-the-stampede-begins" class="table-of-contents__link toc-highlight"><strong>The Problem: The Stampede Begins</strong></a></li><li><a href="#the-solution-request-hedging-debouncing" class="table-of-contents__link toc-highlight"><strong>The Solution: Request Hedging (Debouncing)</strong></a><ul><li><a href="#approach-1-the-busy-wait-spinlock" class="table-of-contents__link toc-highlight"><strong>Approach 1: The Busy Wait (Spinlock)</strong></a></li><li><a href="#approach-2-the-waitnotify-mechanism-jvm-locksfutures" class="table-of-contents__link toc-highlight"><strong>Approach 2: The Wait/Notify Mechanism (JVM Locks/Futures)</strong></a></li><li><a href="#the-pragmatic-scope-jvm-vs-distributed-locks" class="table-of-contents__link toc-highlight"><strong>The Pragmatic Scope: JVM vs. Distributed Locks</strong></a></li></ul></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"></div></footer></div>
</body>
</html>